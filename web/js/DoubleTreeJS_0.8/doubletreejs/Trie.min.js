/* (This is the new BSD license.)
* Copyright (c) 2012-2014, Chris Culy
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Chris Culy nor the 
*		names of its contributors may be used to endorse or promote 
*		products from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Chris Culy
* ``AS IS'' AND ANY OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
* ARE DISCLAIMED. IN NO EVENT SHALL Chris Culy
* BE LIABLE FOR ANY, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
* CONSEQUENTIAL DAMAGES INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
* GOODS OR SERVICES; OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
* CAUSED AND ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
* TORT INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/"use strict";

var doubletree = doubletree || {};

(function() {
doubletree.Trie = function(e, t, n, r, i) {
function p(e, t, n) {
this.id = t;
this.count = n;
this.info = {
count: n,
ids: {}
};
if (e == null) {
this.item = o;
} else {
this.item = e;
this.info.ids = {};
this.info.ids[t] = true;
var r = e.split(f);
for (var i in r) {
this.info[a[i]] = [ r[i] ];
}
}
this.nodes = {};
this.addNgram = function(e, t, n) {
if (!n) {
n = 1;
}
var r, i;
if (e.length > 0) {
r = e.shift();
var h = r.split(f);
if (c && this.item == o) {
i = "";
} else {
i = h.filter(function(e, t) {
return l.indexOf(a[t]) > -1;
}).map(function(e) {
if (u) {
return e.toLocaleLowerCase();
}
return e;
}).join(f);
}
} else {
r = s;
i = r;
}
var d;
if (i in this.nodes && this.nodes[i] instanceof p) {
d = this.nodes[i];
d.info.count += n;
d.info.ids[t] = true;
for (var v in h) {
var m = h[v];
if (d.info[a[v]].indexOf(m) == -1) {
d.info[a[v]].push(m);
}
}
} else {
d = new p(r, t, n);
this.nodes[i] = d;
}
if (r != s) {
d.addNgram(e, t, n);
}
};
this.getUniqRoot = function() {
if (this.item == o) {
var e = Object.keys(this.nodes);
if (e.length == 1) {
return this.nodes[e[0]];
}
}
return this;
};
this.toTree = function(e) {
function t(e, n, r) {
var i = {
children: []
};
i.name = r.item;
i.info = {};
for (var s in r.info) {
if (typeof r.info[s] === "Object") {
i.info[s] = {};
for (var o in r.info[s]) {
i.info[s][o] = this.info[s][o];
}
} else {
i.info[s] = r.info[s];
}
}
i.pruned = {};
for (var u in r.nodes) {
var a = r.nodes[u];
var f = e[n];
if (!f || f && f(a.info)) {
i.children.push(t(e, n + 1, a));
if (a.pruned != {}) {
d(i.pruned, a.pruned);
}
} else {
d(i.pruned, a.info.ids);
}
}
i.info.continuations = i.children.length;
if (i.children.length == 0) {
i.children = null;
i.maxChildren = 0;
if (i.name) {
i.maxLen = i.name.length;
} else {
i.maxLen = 0;
}
i.minCount = i.info.count;
} else {
var l = d3.max(i.children.map(function(e) {
return e.maxChildren;
}));
i.maxChildren = Math.max(i.children.length, l);
var c = d3.max(i.children.map(function(e) {
return e.maxLen;
}));
i.maxLen = Math.max(c, i.name.length);
i.minCount = d3.min(i.children.map(function(e) {
return e.minCount;
}));
}
return i;
}
if (!e) {
e = [];
}
var n = JSON.parse(JSON.stringify(this));
return t(e, 0, n);
};
}
function d(e, t) {
for (var n in t) {
e[n] = t[n];
}
}
var s = " ";
var o = "_root_";
var u = !e && true;
if (!t) {
t = [ "item" ];
}
var a = t;
if (!f) {
f = "	";
}
var f = n;
if (!l) {
l = [ a[0] ];
}
var l = r;
var c = i;
if (undefined == c) {
c = true;
}
var h = new p(o, -1, 0);
this.addNgram = function(e, t, n) {
h.addNgram(e, t, n);
};
this.getUniqRoot = function() {
var e = new doubletree.Trie(!u, a, f, l);
e.trie(h.getUniqRoot());
return e;
};
this.toTree = function(e, t) {
return h.toTree(e, t);
};
this.serialize = function() {
return JSON.stringify(this);
};
this.deserialize = function(e) {
var t = JSON.parse(e);
s = t.endNG();
o = t.rootName();
u = t.caseSensitive();
a = t.fieldNames();
f = t.fieldDelim();
l = t.distinguishingFieldsArray();
h = t.trie();
};
this.endNG = function() {
return s;
};
this.rootName = function() {
return o;
};
this.trie = function(e) {
if (arguments.length > 0) {
h = e;
}
return h;
};
this.caseSensitive = function() {
return !u;
};
this.fieldNames = function() {
return a;
};
this.fieldDelim = function() {
return f;
};
this.distinguishingFieldsArray = function() {
return l;
};
};
})();