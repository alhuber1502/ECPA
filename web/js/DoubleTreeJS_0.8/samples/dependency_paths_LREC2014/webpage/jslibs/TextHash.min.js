/* (This is the new BSD license.)
* Copyright (c) 2012-2013, Chris Culy
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Chris Culy nor the 
*		names of its contributors may be used to endorse or promote 
*		products from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Chris Culy
* ``AS IS'' AND ANY OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
* ARE DISCLAIMED. IN NO EVENT SHALL Chris Culy
* BE LIABLE FOR ANY, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
* CONSEQUENTIAL DAMAGES INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
* GOODS OR SERVICES; OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
* CAUSED AND ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
* TORT INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/"use strict";

var textmodel = textmodel || {};

(function() {
  textmodel.TextHash = function(string, caseSensitive, fldNames, fldDelim, distinguishingFldsArray, baseField, useRecords) {
    function convertItem(inItem) {
      var flds = inItem.split(fldDelim);
      var item = flds[that.baseFieldIdx];
      if (!caseSensitive) {
        item = item.toLocaleLowerCase();
      }
      for (var f = 0, n = flds.length; f < n; f++) {
        if (f == that.baseFieldIdx) {
          continue;
        }
        if (distinguishingFldsArray.indexOf(fldNames[f]) > -1) {
          item += "" + fldDelim + flds[f];
        }
      }
      return item;
    }
    function itemToObject(inItem) {
      var flds = inItem.split(fldDelim);
      var what = {};
      flds.forEach(function(fld, idx) {
        what[fldNames[idx]] = fld;
      });
      return what;
    }
    var that = this;
    var kRecDelim = String.fromCharCode(30);
    this.useRecords = useRecords && true;
    this.baseField = baseField;
    this.baseFieldIdx = fldNames.indexOf(baseField);
    if (this.baseFieldIdx == -1) {
      this.baseFieldIdx = 0;
    }
    if (this.useRecords) {
      string = string.replace(/\s*\n\n+/g, " " + kRecDelim + " ");
    }
    this.items = string.replace(/\s*\n\s*/g, " ").trim().split(" ");
    this.itemObjs = [];
    this.indices = {};
    this.numTypes = 0;
    this.numTokens = this.items.length;
    var numItems = this.items.length;
    var lastItem = numItems - 1;
    if (string != "") {
      for (var i = 0; i < numItems; i++) {
        var item = convertItem(this.items[i]);
        this.itemObjs[i] = itemToObject(item);
        if (!(item in this.indices && this.indices[item] instanceof Array)) {
          this.indices[item] = [];
        }
        try {
          this.indices[item].push(i);
        } catch (e) {
          console.log("Couldn't add: " + item);
        }
      }
    }
    this.numTypes = Object.keys(this.indices).length;
    this.containsItem = function(item) {
      return convertItem(item) in this.indices;
    };
    this.containsIndex = function(item) {
      return item in this.indices;
    };
    this.getItem = function(item, contextLen, includeOnly, itemIsRegex, contextFilters, maxRandomHits) {
      var prefixArray = [], itemArray = [], suffixArray = [], idArray = [];
      if (that.useRecords) {
        var field1 = fldNames[0];
        if (contextFilters == null) {
          contextFilters = {};
        }
        if (typeof contextFilters["leftEnd"] === "undefined") {
          contextFilters["leftEnd"] = {};
        }
        var tmp = contextFilters["leftEnd"][field1];
        if (typeof contextFilters["leftEnd"][field1] === "undefined") {
          contextFilters["leftEnd"][field1] = [];
        }
        contextFilters["leftEnd"][field1].push(kRecDelim);
        if (typeof contextFilters["rtEnd"] === "undefined") {
          contextFilters["rtEnd"] = {};
        }
        if (typeof contextFilters["rtEnd"][field1] === "undefined") {
          contextFilters["rtEnd"][field1] = [];
        }
        contextFilters["rtEnd"][field1].push(kRecDelim);
      }
      var filterContext = function() {
        return function() {
          return true;
        };
      };
      var chopLeftEnd = function(a) {
        return a;
      };
      var chopRtEnd = function(a) {
        return a;
      };
      if (contextFilters) {
        if (contextFilters["include"]) {
          var toInclude = contextFilters["include"];
          filterContext = function(startIndex) {
            return function(elt, idx, contextArray) {
              for (var fld in toInclude) {
                if (toInclude[fld].indexOf(that.itemObjs[idx + startIndex][fld]) > -1) {
                  return true;
                }
              }
              return false;
            };
          };
        } else if (contextFilters["exclude"]) {
          var toExclude = contextFilters["exclude"];
          filterContext = function(startIndex) {
            return function(elt, idx, contextArray) {
              for (var fld in toExclude) {
                var tmp = that.itemObjs[idx + startIndex];
                if (toExclude[fld].indexOf(that.itemObjs[idx + startIndex][fld]) > -1) {
                  return false;
                }
              }
              return true;
            };
          };
        }
        if (contextFilters["leftEnd"]) {
          chopLeftEnd = function(a, startIndex) {
            var where = 0;
            var OK = true;
            for (var idx = a.length - 1; idx > -1; idx--) {
              for (var fld in contextFilters["leftEnd"]) {
                if (contextFilters["leftEnd"][fld].indexOf(that.itemObjs[idx + startIndex][fld]) > -1) {
                  OK = false;
                }
              }
              if (!OK) {
                where = idx + 1;
                break;
              }
            }
            return a.slice(where, a.length + 1);
          };
        }
        if (contextFilters["rtEnd"]) {
          chopRtEnd = function(a, startIndex) {
            var OK = true;
            return a.filter(function(elt, idx) {
              if (!OK) {
                return false;
              }
              for (var fld in contextFilters["rtEnd"]) {
                if (contextFilters["rtEnd"][fld].indexOf(that.itemObjs[idx + startIndex][fld]) > -1) {
                  OK = false;
                  break;
                }
              }
              return OK;
            });
          };
        }
      }
      var numItems = this.items.length;
      var lastItem = numItems - 1;
      var hits;
      if (itemIsRegex) {
        var thisThat = this;
        var re = new RegExp(item, "i");
        var hitArrays = Object.keys(this.indices).filter(function(item) {
          return re.test(item);
        }).map(function(hit) {
          return thisThat.indices[hit];
        });
        hits = [];
        hitArrays.forEach(function(arr) {
          arr.forEach(function(elt) {
            hits.push(elt);
          });
        });
        thisThat = null;
      } else {
        hits = this.indices[item];
      }
      var n = hits.length;
      var nMinus1 = n - 1;
      for (var i = 0; i < n; i++) {
        if (includeOnly != null && !(i in includeOnly)) {
          continue;
        }
        idArray.push(i);
        var thisIndex = hits[i];
        var origItem = this.items[thisIndex];
        itemArray.push(origItem);
        if (thisIndex == 0) {
          prefixArray.push([]);
        } else {
          var pStart = Math.max(0, thisIndex - contextLen);
          var prefs = chopLeftEnd(this.items.slice(pStart, thisIndex), pStart);
          pStart += contextLen - prefs.length;
          prefixArray.push(prefs.filter(filterContext(pStart)));
        }
        if (thisIndex == nMinus1) {
          suffixArray.push([]);
        } else {
          var sEnd = Math.min(lastItem, thisIndex + contextLen);
          var sStart = thisIndex + 1;
          var suffs = chopRtEnd(this.items.slice(sStart, sEnd + 1), sStart);
          suffixArray.push(suffs.filter(filterContext(sStart)));
        }
      }
      if (maxRandomHits !== null && maxRandomHits > 0) {
        var indices = d3.shuffle(d3.range(0, itemArray.length)).slice(0, maxRandomHits);
        prefixArray = d3.permute(prefixArray, indices);
        itemArray = d3.permute(itemArray, indices);
        suffixArray = d3.permute(suffixArray, indices);
        idArray = d3.permute(idArray, indices);
      }
      return [ prefixArray, itemArray, suffixArray, idArray ];
    };
    this.getItems = function(regex, contextLen, includeOnly, contextFilters, maxRandomHits) {
      return this.getItem(regex, contextLen, includeOnly, true, contextFilters, maxRandomHits);
    };
    this.getItemContext = function(item, contextLen, id, itemIsRegex) {
      var toGet = {};
      toGet[id] = true;
      var results = this.getItem(item, contextLen, toGet, itemIsRegex);
      var what = results[0][0].join(" ") + " " + results[1][0] + " " + results[2][0].join(" ");
      return what;
    };
    this.getUniqItems = function() {
      return Object.keys(this.indices).sort(function(A, B) {
        var a = A.toLocaleLowerCase();
        var b = B.toLocaleLowerCase();
        if (a < b) return -1;
        if (a > b) return 1;
        return 0;
      }).filter(function(i) {
        return i !== kRecDelim;
      });
    };
    this.getUniqItemsWithCounts = function() {
      var what = [];
      for (item in this.indices) {
        what.push(item + "	" + this.indices[item].length);
      }
      what.sort(function(A, B) {
        var a = A.toLocaleLowerCase();
        var b = B.toLocaleLowerCase();
        if (a < b) return -1;
        if (a > b) return 1;
        return 0;
      });
      return what;
    };
    this.fromJSON = function(obj) {
      this.baseField = obj.baseField;
      this.baseFieldIdx = obj.baseFieldIdx;
      this.items = obj.items;
      this.indices = obj.indices;
      this.numTypes = obj.numTypes;
      this.numTokens = obj.numTokens;
      this.useRecords = obj.useRecords;
    };
    this.itemToIndex = function(item) {
      return convertItem(item);
    };
  };
})();